# コンパイラ

QiqテンプレートはネイティブのPHPを使用しますが、`{{ ... }}` 構文シュガーにはコンパイル処理が必要です。このプロセスは非常にシンプルで、素朴なものですが、確かに存在します：

- コンパイル済みテンプレートがキャッシュディレクトリに既に存在し、ソーステンプレートファイルよりも新しい場合、_QiqCompiler_ は既存のコンパイル済みテンプレートを返します。そうでない場合...

- _QiqCompiler_ はソーステンプレートファイルを読み込み、正規表現を使用して `{{ ... }}` タグを分割し、_QiqToken_ オブジェクトとして保持します。

- 次に、_QiqCompiler_ は各 _QiqToken_ を呼び出して `{{ ... }}` タグのPHPコード置換を取得し、すべての部分を順番に再構築します。

- コンパイル済みテンプレートはコンパイラのキャッシュディレクトリに保存されます。同じソーステンプレートは再度コンパイルされません - 少なくとも、再保存されてタイムスタンプが更新され、コンパイル済みバージョンよりも新しくなるまでは。

## キャッシュパス

_QiqCompiler_ のキャッシュパスは、デフォルトで [`sys_get_temp_dir()`](https://php.net/sys_get_temp_dir) ディレクトリに `/qiq` を追加したものですが、`Template::new()` で任意のパスを指定できます：

```php
$template = Template::new(
    cachePath: '/path/to/qiqcache/'
);
```

_QiqCompiler_ は、ソーステンプレートファイルのフルパスを使用してコンパイル済みテンプレートをキャッシュに保存します。例えば、キャッシュパスが `/private/tmp` で、ソーステンプレートファイルが `/www/site/resources/templates/foo.php` にある場合、コンパイル済みテンプレートファイルは次の場所にキャッシュされます：

`/private/tmp/www/site/resources/templates/foo.php`

コンパイルエラーが発生した場合、キャッシュパスの一部としてソーステンプレートの完全なパスがあると、元のテンプレートを見つけるのに役立ちます。

## キャッシュのクリア

キャッシュをクリアするには、_Template_ 内の _Compiler_ を取得し、その `clear()` メソッドを呼び出します。

```php
$template->getCompiler()->clear();
```

## コンパイラの無効化

Qiq構文を使用せず、テンプレートファイルでPHPのみを使用することが絶対に確実な場合は、`$cachePath` を false に設定して _Template_ を作成できます：

```php
$template = Template::new(
    cachePath: false
);
```

これにより、_Template_ はテンプレートファイルを全くコンパイルまたはキャッシュしない _NonCompiler_ を使用するようになります。
